package starlogoc;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

//import starlogoc.Variable.VariableScope;
//import starlogoc.Variable.VariableType;
import terraineditor.TerrainFileFormatUtils;

public class StarLogo {
	
	//TODO cmcheng
	//Buffer for bounce information, contains multiples of 6 floats:
	//  x1, y1, x2, y2, color, radius
	public FloatBuffer lineBuffer;
	public static final int LINE_BUFFER_SIZE = 10*6;
	
	private static final String saveTitle = "`globals`";
	private static final String saveEnd = "`";
    
    public static final int MAX_TURTLES = 4096;
    /** Maximum number of bounces per turtle */
    public static final int MAX_BOUNCES = 32;
    /** Maximum number of (total) sounds */
    public static final int MAX_SOUNDS = 64;
    
    static final int WIDTH = 101;
    static final int HEIGHT = 101;
    static final int CELLSIZE = 4;
    
    /**
     * The list of runtime exceptions that can be generated by the vm. 
     * MUST coordinate this with the VM's list of exception indices.
     */
    private static final String[] SL_ERRORS = {
        "Index out of bounds",
        "Invalid array length",
        "Cannot pick item from zero-length list"
    };
    
    public volatile boolean runningp = false;
    public volatile boolean juststartedp = false;
//    private static Set<StarLogoCObserver> observers = new LinkedHashSet<StarLogoCObserver>();
    private Object lock = new Float(1);
    
//    private TurtleManager tm;
    private PatchManager pm;
//    private static ShapeManager sm;
    
    private int numGlobals;
    private LongBuffer globalHeap;
//    private List<Variable> varList = new ArrayList<Variable>();
    
    /** keeps track of all calling threads.  We need to seed the RNG of each new thread. */
    private HashSet<Thread> callingThreads = new HashSet<Thread>();
    
    /** maps breeds to slnums, and breed icons to slnums */
    private ConcurrentHashMap<String, Long> breedMap, breedShapeMap;
    
    /** StarLogoC.dll must be in the working directory to load the native code */
    static {
        try {
            System.loadLibrary("StarLogoC");
        } catch (Exception e) {e.printStackTrace(); }
    }
    
    public static void main(String[] args) {
        new StarLogo();
    }
    
    public void run() {
        runningp = true;
        juststartedp = true;
    }
    
    public StarLogo() {
        breedMap = new ConcurrentHashMap<String, Long>();
        breedShapeMap = new ConcurrentHashMap<String, Long>();
        
//        tm = new TurtleManager(MAX_TURTLES, MAX_BOUNCES, MAX_SOUNDS, this);
        pm = new PatchManager(WIDTH, HEIGHT, this);
        
//        init(WIDTH, HEIGHT, CELLSIZE);
        
//        setNumGlobals(0);
        
        //TODO cmcheng init the bounce buffer
//        //Number of bytes: BOUNCE_STREAM_SIZE*4 bytes per float
//        lineBuffer = ByteBuffer.allocateDirect(LINE_BUFFER_SIZE*4).order(ByteOrder.nativeOrder()).asFloatBuffer();		
//        setupLineBuffer(lineBuffer);
    }
    
    // NJM 
    public StarLogo(TurtleManager tm) {
        breedMap = new ConcurrentHashMap<String, Long>();
        breedShapeMap = new ConcurrentHashMap<String, Long>();
        
//        this.tm = tm;
        
        // NJM
        // can't create patch manager until StarLogo is created
        // I initially tried just creating the patchmanger and
        // turtlemanager twice (once in the constructor) and then
        // my own copies that I passed in through the setters, but
        // ran out of memory.  Ideally I could have a new constructor
        // that took a patchmanager and a turtlemanager, but
        // unfortunately the patchmanager uses StarLogo in the
        // constructor so it has to be created after StarLogo
        this.pm = null;
        
//        init(WIDTH, HEIGHT, CELLSIZE);
        
//        setNumGlobals(0);
        
        //TODO cmcheng init the bounce buffer
//        //Number of bytes: BOUNCE_STREAM_SIZE*4 bytes per float
//        lineBuffer = ByteBuffer.allocateDirect(LINE_BUFFER_SIZE*4).order(ByteOrder.nativeOrder()).asFloatBuffer();		
//        setupLineBuffer(lineBuffer);

    }
    
//    public TurtleManager getTurtleManager() {
//        return tm;
//    }
    
    public PatchManager getPatchManager() {
        return pm;
    }
    
//    public ShapeManager getShapeManager() {
//    	return sm;
//    }
//    
//    public static void setShapeManager(ShapeManager s) {
//    	sm = s;
//    }
    // NJM
    public void setPatchManager(PatchManager pm) {
    	this.pm = pm;
    }

    // NJM
    public void setTurtleManager(TurtleManager tm) {
//    	this.tm = tm;
    }

//    public void addObserver(StarLogoCObserver sco) {
//        observers.add(sco);
//    }
//    
//    public void removeObserver(StarLogoCObserver sco) {
//        observers.remove(sco);
//    }
//    
//    public void handleMenuEvent(ActionEvent e) {
//        for (StarLogoCObserver observer : observers)
//            observer.handleMenuEvent(e);
//    }
    
//    // native functions for manipulating the VM's breed->shape association lists
//    private native void add_breed(long name_heap_ptr, long shape_heap_ptr);
//    private native void delete_breed(long name_heap_ptr);
//    private native void rename_breed(long old_name_heap_ptr, long new_name_heap_ptr, long shape_heap_ptr);
//    private native void update_shape(long name_heap_ptr, long shape_heap_ptr);
//    
//    public void deleteAllBreeds() {
//    	for (String s : breedMap.keySet()) {
//    	   	deleteBreed(s);
//    	}
//    }
//    
//    public void setBreeds(String[] breeds, String[] breedNames) {
//    	deleteAllBreeds();
//        for(int i = 0; i < breeds.length; i++) {
//            addBreed(breeds[i], breedNames[i]);
//        }
//    }
//    
//    public boolean doesBreedExist(String breedName){
//        return breedMap.containsKey(breedName);
//    }
//    
//    public void addBreed(String breedName, String breedDefaultShape) {
//    	if (breedMap.containsKey(breedName)) {
//    		throw new RuntimeException("Cannot create breed with duplicate name! "+breedName);
//    	}
//        
//        // store the names on the heap and create pointers to them
//        long breedNamePtr = new Long(addToHeap(breedName));
//        long breedDefaultShapePtr = new Long(addToHeap(breedDefaultShape));
//        
//        // add the pointers to the appropriate string->pointer map
//        //System.out.println("ADDING BREED TO MAPPING: Breed="+breedName + ", num="+breedNamePtr);
//        breedMap.put(breedName, breedNamePtr);
//        breedShapeMap.put(breedDefaultShape, breedDefaultShapePtr);
//        
//        // call vm function to add entry in name->shape table (technically name_ptr->shape_ptr table)
//        add_breed(breedNamePtr, breedDefaultShapePtr);
//    }
//    
//    public void deleteBreed(String breedName) {
//                /* call to vm to kill all turtles with this breed and then
//                 * remove the breed from its breed->shape table. */
//        delete_breed((long)breedMap.get(breedName));
//        
//        // now remove the breed from the breedName->namePtr map
//        breedMap.remove(breedName);
//    }
//    
//    public void renameBreed(String oldName, String newName, String newShape) {
//        // add the new breed name
//        addBreed(newName, newShape);
//        
//        // update turtles of old breed name to have new breed name
//        rename_breed((long)breedMap.get(oldName), (long)breedMap.get(newName), (long)breedShapeMap.get(newShape));
//        
//        // delete the old breed name
//        deleteBreed(oldName);
//    }
//    
//    public void updateBreedShape(String breedName, String newShape) {
//        
//        // add the new shape and its pointer to the shape map
//        long newShapePtr = new Long(addToHeap(newShape));
//        breedShapeMap.put(newShape, newShapePtr);
//        
//        // update the breed->shape table in the VM
//        update_shape((long)breedMap.get(breedName), newShapePtr);
//    }
    
    public void setLock(Object lock) {
        this.lock = lock;
    }
    
    public Object getLock() {
        return lock;
    }
    
//    public boolean runVM(int framesPerRun) {
//        return oneStep(framesPerRun, seedThisThread());
//    }
    
    /**
     * Stops execution as quickly as possible
     */
//	public void stopNow() {
//		interruptExecution();
//	}
	// interrupts the VM execution loop causing the VM to return almost immediately
//	private native void interruptExecution();
	
//    public int seedThisThread() {
//        if (!callingThreads.contains(Thread.currentThread())) {
//            callingThreads.add(Thread.currentThread());
//            return -1; //signal that we need a random seed for this new thread
//        }
//        return 0; //otherwise this thread's RNG has already been seeded
//    }
//    
//    public void clearAll() {
//        clearPatches();
//        clearTurtles();
//    }
//    
//    public void clearTurtles() {
//        synchronized(lock) {
//            clearTurtles0();
//        }
//    }
    
    public void clearPatches() {
        pm.getCurrentTerrain().clearPatches();
    }
    
    public void scatterPC(double red, double green, double blue, double black) {
        pm.getCurrentTerrain().scatterPC(red, green, blue, black);
    }
    
//    public void createTurtles(int num, String breed, String breedIcon, int codePos) {
//        long breedSlnum = getBreedSlnum(breed);
//        long breedIconSlnum = getBreedShapeSlnum(breed);
//        if (lock != null) {
//            synchronized(lock) {
//                createTurtles0(num, breedSlnum, breedIconSlnum, codePos);
//            }
//        } else {
//            createTurtles0(num, breedSlnum, breedIconSlnum, codePos); // special case for startup
//        }
//    }
    
//    public int createTurtle(String breed) {
//    	long breedSlnum = getBreedSlnum(breed);
//        long breedIconSlnum = getBreedShapeSlnum(breed);
//        if (lock != null) {
//            synchronized(lock) {
//                return createTurtle(breedSlnum, breedIconSlnum);
//            }
//        } else {
//            return createTurtle(breedSlnum, breedIconSlnum);
//        }
//    }
    
//    public void killTurtle(int who) {
//    	killTurtle0(who);
//    }
//    
    /**
     * Creates a turtle with the given who number
     */
//    public void createTurtleWho(int who, String breed, String breedIcon) {
//    	long breedSlnum = getBreedSlnum(breed);
//        long breedIconSlnum = getBreedShapeSlnum(breed);
//        System.out.println("breed:" + breedSlnum + ", breedIcon:" + breedIconSlnum);
//        if (lock != null) {
//            synchronized(lock) {
//                tm.createTurtleWho(who, breedSlnum, breedIconSlnum);
//            }
//        } else {
//        	 // special case for startup TODO: may not be necessary
//            tm.createTurtleWho(who, breedSlnum, breedIconSlnum);
//        } 
//    }
//    
    /**
     * Scatters agents of specified breed.  If the specified breed is null, scatter everyone.
     * @param breed desired breed to scatter.  
     */
//    public void scatterTurtles(String breed) {
//        Long breedSlnumLong;
//        if(breed == null)
//            breedSlnumLong = null; //means to scatter everyone
//        else 
//            breedSlnumLong = breedMap.get(breed);
//        
//        long breedSlnum;
//        
//        if(breedSlnumLong != null)
//            breedSlnum = breedSlnumLong.longValue();
//        else
//            breedSlnum = doubleToSlnum(-1);
//        
//        synchronized(lock) {
//            scatterTurtles0(breedSlnum, seedThisThread());
//        }
//    }
//    
    public void setPatchTerrain(int index) {
        pm.setPatchTerrain(index);
    }
    
//    // the following methods are called from the native C code
//    // so they are actually being used. 
//    @SuppressWarnings("unused")
//    private void setPatchTerrain(String name) {
//    	pm.setPatchTerrain(name); 
//    }
//    
//    @SuppressWarnings("unused")
//    private void saveTerrainSnapshot(String name) {
//    	pm.saveTerrainSnapshot(name);
//    }
//    
//    @SuppressWarnings("unused")
//    private void saveCurrentTerrainSnapshot() {
//    	pm.saveCurrentTerrainSnapshot();
//    }
//
//    @SuppressWarnings("unused")
//    private void reloadTerrainFromSnapshot() {
//    	pm.reloadCurrentTerrainSnapshot();
//    }
//    
//    @SuppressWarnings("unused")
//    private String currentLevelName() {
//    	return pm.getTerrainName(pm.getCurrentTerrainIndex());
//    }
//    
//    @SuppressWarnings("unused")
//    private String levelName(int index) {
//    	return pm.getTerrainName(index);
//    }
//    
//    @SuppressWarnings("unused")
//    private int getLevelIndex(String name) {
//    	return pm.getTerrainIndex(name);
//    }
//    
//    @SuppressWarnings("unused")
//    private String randomShape() {
//     	if(sm==null) {
//    		return "Turtles";
//    	}
//    	else
//    	{
//    		Object[] shapeNames = sm.getAllShapeNames();
//    		int index = (int) Math.floor(Math.random() * (shapeNames.length+.9999));
//    		return (String) shapeNames[index];
//    	}
//    }
    
//    private native boolean oneStep(int framesPerRun, int reSeedRNG);
////    public native void init(int width, int height, int cellsize);
//    public native void setInstructions(long[] insts, int arrayposition);
//    public native void createTurtles0(int num, long breed, long breedIconSlnum, int codePos);
//    private native int createTurtle(long breed, long breedIconSlnum);
//    private native void killTurtle0(int who);
//    public native void clearTurtles0();
//    public native void scatterTurtles0(long breed, int reseed);
//    public static native int sizeOfTurtle();
//    public static native int sizeOfShownTurtle();
//    public static native int sizeOfVisibleTurtle();
//    public static native int sizeOfExportTurtle();
//    public static native int sizeOfBounce();
//    public static native int sizeOfSound();
//    
    public static native long intToSlnum(int num);
    public static native int slnumToInt(long num);
    public static native long doubleToSlnum(double num);
    public static native double slnumToDouble(long num);
    public static native long booleanToSlnum(boolean val);
    public static native boolean slnumToBoolean(long num);
//    
//    // methods to deal with internal StarLogoTime
//    public native double getStarLogoTime(); // returns the internal SL time
//    public native void setStarLogoTime(double time); // set the internal SL time
//    
//    // Methods to interface with turtle collisions
//    public static native void addCollisions(int who, int numCollisions,
//            IntBuffer turtleCollisions);
//    public static native void updateCollisions(); // do a native code collisions check
//    public static native void clearInterestInCollisions();
//    public static native void interestInCollision(long whoA, long whoB);
//
//    //use to update the turtle's bounding cylinder
//    // Note!! 0,0 cylinder center is the point that touches the ground at yheightabove = 0
//    // Bottom will usually be 0
//    public static native void setBoundingCylinder(int who, float radius, float top, float bottom);
//    
//    public static native void setJoystickData(ByteBuffer joystickData);
//    public static native void setKeyboardData(ByteBuffer keyboardData);
//    
//    public static native void setNetworkStatus(boolean networked, int hostnum, int actions[]);
//    public static native long[] getExportTurtles(int hostnum);
//    private static native void importTurtles(long[] turtleHeap);
//    private static native void setImportBreedMap(long[] breedMap);
//    
//    public static native byte[] getKeyDeltas();
//    public static native void importKeyDeltas(int hostnum, byte[] deltas);
//
//    /** @return A heap pointer slnum */
//    public static native long copyToHeap(long[] heapSection);
//    /** @return A heap pointer slnum */
//    public static native long addToHeap(String s);
//    public static native long getBreedSlnum(String s);
//    public static native long getBreedShapeSlnum(String s);
//    public static native String getStringFromHeap(long heapptr);
//    // Methods to interface with StarLogo lists
//    public static native long allocateList(int size);
//    public native void setListElements(long heapptr, long[] slnumValues);
//    public native Object[] getList(long heapptr);
//    public native int getListSize(long heapptr);
//    public native Object getListElement(long heapptr, int index);
    /** @return A heap pointer to the list */
//    public long addToHeap(StarLogoArray array) {
//        Object[] elts = array.getElements();
//        long[] slnums = new long[elts.length];
//        long heapPointer = allocateList(elts.length);
//        for (int i = 0; i < elts.length; i++) {
//            if (elts[i] instanceof StarLogoArray) {
//                slnums[i] = addToHeap((StarLogoArray)elts[i]);
//            } else if (elts[i] instanceof String) {
//                slnums[i] = addToHeap((String)elts[i]);
//            } else if (elts[i] instanceof Long) {
//                // Boolean SLNUM
//                slnums[i] = ((Long)elts[i]).longValue();
//            } else if (elts[i] instanceof Double) {
//                // Boolean or Number SLNUM
//                slnums[i] = doubleToSlnum(((Double)elts[i]).doubleValue());
//            }
//            setListElements(heapPointer, slnums);
//        }
//        return heapPointer;
//    }
//    
//    public native void reset();
    
//    public void update(Graphics g) { paint(g); }
//    public native void paint(Graphics g);
    
//    public native double getTurtleInfo(int who, String field);
//    public native long getTurtleVars(int who, int slot);
//    
//    public long getBreedSlnumOld(String breed) {
//        Long result = breedMap.get(breed);
//        
//        if(result == null) {
//            result = new Long(addToHeap(breed));
//            
//            breedMap.put(breed, result);
//        }
//        
//		//System.out.println("breed is " + breed+". number is: " + (result.longValue()&0xFFFFF));
//        return result.longValue(); 
//    }
//    
//    public long getBreedShapeSlnumOld(String breedShape) {
//        Long result = breedShapeMap.get(breedShape);
//        
//        if(result == null) {
//            result = new Long(addToHeap(breedShape));
//            
//            breedShapeMap.put(breedShape, result);
//        }
//        
//        return result.longValue();
//    }
//    
//    public void setGlobalVariable(int index, double value) {
//        globalHeap.put(index, Double.doubleToRawLongBits(value));
//    }
//    
//    public double getGlobalVariable(int index) {
//        // New variables that have not yet been compiled but are used 
//        // (eg. in sliders) will not be reflected in the VM heap yet --
//        // so we "initialize" to zero
//        if (index >= globalHeap.limit()) return 0;
//        return Double.longBitsToDouble(globalHeap.get(index));
//    }
//    
//    /** Called by the VM native code whenever a global variable is changed */
//    @SuppressWarnings("unused")
//    private void globalVariableChanged(int index) {
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        
//        while(i.hasNext()) i.next().globalVariableChanged(index);
//    }
//    
//    /** Called by the VM when the clock ticks. */
//    @SuppressWarnings("unused")
//    private void vmTicked(double slTime) {
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        while (i.hasNext()) i.next().vmTicked(slTime);
//    }
    
//    public boolean selectedAgent(int who) {
//        for (StarLogoCObserver o : observers)
//            return o.selectedAgent(who);
//        return false;
//    }
//    
//    public boolean deselectedAgent(int who) {
//        for (StarLogoCObserver o : observers)
//            return o.deselectedAgent(who);
//        return false;
//    }
    
//    public void noTurtlesAlive() {
//        for(Iterator<StarLogoCObserver> it = observers.iterator(); it.hasNext(); it.next().noTurtlesAlive());
//    }
//    
//    public static boolean isAnythingRunning() {
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        while (i.hasNext()) {
//            if (i.next().isAnythingRunning()) return true;
//        }
//        return false;
//    }
    
//    public double getMonitorValue(int codePos) {
//        synchronized(lock) {
//            return slnumToDouble(getMonitorValue0(intToSlnum(codePos)));
//        }
//    }
//    
//    public boolean getMonitorBooleanValue(int codePos) {
//        synchronized(lock) {
//            return slnumToBoolean(getMonitorValue0(intToSlnum(codePos)));
//        }
//    }
//    
//    public String getMonitorStringValue(int codePos) {
//        synchronized(lock) {
//        		return getStringFromHeap(getMonitorValue0(intToSlnum(codePos)));
//        }
//    }
    
//    private native long getMonitorValue0(long codePos);
//    
//    @SuppressWarnings("unused")
//    private void runForSomeTimeBlockDone(double id)  // Called by the VM when a run-for-some-time block has finished executing
//    {
//        long actualID = (long)id;
//        
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        
//        while(i.hasNext()) i.next().runForSomeTimeBlockDone(actualID);
//    }
//    
//    /** Called by the VM when there are turtles to export */
//    @SuppressWarnings("unused")
//    private void turtlesToExport()
//    {        
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        
//        while(i.hasNext()) i.next().turtlesToExport();
//    }
//    
//    /** Called by the VM when there are keys to export */
//    @SuppressWarnings("unused")
//    private void keysToExport()
//    {        
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        
//        while(i.hasNext()) i.next().keysToExport();
//    }
//    
//    /** Called by the VM for each turtle to export. */
//    @SuppressWarnings("unused")
//    private void turtleExportBreed(long slnum, String breed) 
//    {
//        Iterator<StarLogoCObserver> i = observers.iterator();
//        while (i.hasNext()) i.next().addExportBreed(slnum, breed);
//    }
//    
    /**
     * Import remote agents.
     * @param turtleHeap The agent data to import 
     */
//    public static synchronized void importTurtles(long[] breeds, long[] turtleHeap) 
//    {
//        assert (breeds.length % 2) == 0;
//        setImportBreedMap(breeds);
//        importTurtles(turtleHeap);
//    }
//    
//    public void runtimeError(int error)
//    {
//        System.out.println("VM Error: " + SL_ERRORS[error]);
//    }
    
//    public void runForSomeTimeBlockTurnedOff(long id) // Called by StarLogoBlocks when the user turns off a run-for-some-time block
//    {
//        runForSomeTimeBlockTurnedOff0(doubleToSlnum((double)id));
//    }
//    
//    private native void runForSomeTimeBlockTurnedOff0(long id);
    
//    public void renameTurtleVariable(Variable oldVar, Variable newVar) {
//        tm.renameVariable(oldVar, newVar);
//    }
//    
//    public void reallocateTurtleVariables(List<Variable> varList) {
//        tm.reallocateVariables(varList);
//    }
    
//    public void renamePatchVariable(Variable oldVar, Variable newVar) {
//        pm.renameVariable(oldVar, newVar);
//    }
//    
//    public void reallocatePatchVariables(List<Variable> varList) {
//        pm.reallocateVariables(varList);
//    }
//    
//    public void setNumGlobals(int newNumGlobals) {
//        numGlobals = newNumGlobals;
//        globalHeap = ByteBuffer.
//                allocateDirect(newNumGlobals * 8).
//                order(ByteOrder.nativeOrder()).
//                asLongBuffer();
//        setNumGlobals(newNumGlobals, globalHeap);
//    }
//    
//    private native void setNumGlobals(int newNumGlobals,
//            LongBuffer globalHeap);
    
//    /**
//     * Replace oldVar with newVar, or does nothing if oldVar does not exist.
//     */
//    public void renameGlobalVariable(Variable oldVar, Variable newVar) {
//        int i = varList.indexOf(oldVar);
//        if (i != -1)
//            varList.set(i, newVar);
//    }
//    
//    public void reallocateGlobalVariables(List<Variable> newVarList) {
//        // Shortcircuit if no changes have been made
//        if (varList.equals(newVarList))
//            return;
//        
//        LongBuffer newGlobalHeap = ByteBuffer.
//                allocateDirect(newVarList.size() * 8).
//                order(ByteOrder.nativeOrder()).
//                asLongBuffer();
//        
//        // Generate a list that maps new var positions to old positions.
//        // -1 signals that this is a new variable that will be initialized to 0.
//        List<Integer> positions = new ArrayList<Integer>(); // Indexes new positions to old positions
//        for (int newPosition = 0; newPosition < newVarList.size(); newPosition++)
//            positions.add(new Integer(varList.indexOf(newVarList.get(newPosition))));
//        
//        int oldPosition;
//        for (int newPosition = 0; newPosition < positions.size(); newPosition++) {
//            oldPosition = positions.get(newPosition).intValue();
//            if (oldPosition == -1) {
//                newGlobalHeap.put(0);
//            } else {
//                newGlobalHeap.put(globalHeap.get(oldPosition));
//            }
//        }
//        
//        varList = new ArrayList<Variable>(newVarList);
//        numGlobals = newVarList.size();
//        globalHeap = newGlobalHeap;
//        setGlobalHeap(numGlobals, globalHeap);
//    }
//    
//    private native void setGlobalHeap(int numGlobals, LongBuffer globalHeap);
//    
//    public native void turtleDoneSaying(int who);
//    
//    public void setScore(double score) {
//        GameManager.getGameManager().setScore(score);
//    }
//    
//    public void showScore() {
//        GameManager.getGameManager().showScore();
//    }
//    
//    public void hideScore() {
//        GameManager.getGameManager().hideScore();
//    }
//    
//    public void showClock() {
//        GameManager.getGameManager().showClock();
//    }
//    
//    public void hideClock() {
//        GameManager.getGameManager().hideClock();
//    }
//    
//    public void resetClock() {
//        GameManager.getGameManager().resetClock();
//    }
//    
//    public void showMiniView()
//    {
//        GameManager.getGameManager().showMiniView();
//    }
//
//    public void hideMiniView()
//    {
//        GameManager.getGameManager().hideMiniView();
//    }
//    
//    public static int getSpeedSliderPosition(){
//        for (StarLogoCObserver observer : observers)
//            return observer.getSpeedSliderPosition();
//        return 0;
//    }
    
//    public String getSaveString() {
//    	StringBuffer save = new StringBuffer();
//    	StringBuffer save2 = new StringBuffer();
//    	save.append("\r\n");
//		save.append(saveTitle);
//        save.append("\r\n");
//		save2.append("<?xml version=\"1.0\" encoding=\"UTF-16\"?>");
//        save2.append("<GLOBALS>");
//        
//        for(Variable v : varList) {
//        	if(v.getScope() == Variable.VariableScope.GLOBAL && !v.isList()) {
//        		String name = TerrainFileFormatUtils.escape(v.getName()); 
//    			switch(v.getType()) {
//    				case BOOLEAN :
//    					save2.append("<VARIABLE scope=\"global\" type=\"boolean\" name=\""+name+"\">"+slnumToBoolean(doubleToSlnum((getGlobalVariable(varList.indexOf(v)))))+"</VARIABLE>"); 
//    					break; 
//    				case NUMBER :
//    					save2.append("<VARIABLE scope=\"global\" type=\"number\" name=\""+name+"\">"+getGlobalVariable(varList.indexOf(v))+"</VARIABLE>");
//    					break;
//    				case STRING :
//    					save2.append("<VARIABLE scope=\"global\" type=\"string\" name=\""+name+"\">"+TerrainFileFormatUtils.escape(getStringFromHeap(doubleToSlnum((getGlobalVariable(varList.indexOf(v))))))+"</VARIABLE>");
//    					break;
//    			}
//    		}
//        }
//        
//        save2.append("</GLOBALS>");  
//        save.append(TerrainFileFormatUtils.getGzippedString(save2.toString()));
//        save.append(saveEnd);
//        save.append("\r\n");
//        return save.toString();     	
//    }
//    
    /**
     * Initializes global variables to their saved values.
     * This assumes that the SLBlockCompiler has been run
     * and that the global variables exist in our internal 
     * variable list.
     */
//    public void loadSaveString(String allContents) {
//    	String contents = new String(allContents);
//		
//		int start = contents.indexOf(saveTitle);
//        if (start < 0)
//            return;
//        int end = contents.indexOf(saveEnd, start + saveTitle.length());
//        if (end < 0)
//            end = contents.length();
//        contents = contents.substring(start + saveTitle.length(), end);
//        
//        // only gunzip if it was gzipped to begin with
//        if (!contents.contains("<?xml version"))
//        	contents = TerrainFileFormatUtils.getGunzippedString(contents);
//        
//        // we need this line to remove the blank spaces before the prologue
//        contents = contents.substring(contents.indexOf("<"));
//        
//        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
//        DocumentBuilder builder;
//        Document doc;
//        try {
//            builder = factory.newDocumentBuilder();
//            doc = builder.parse(new InputSource(new StringReader(contents)));
//            Element root = doc.getDocumentElement();
//            if (root.getNodeName().equals("GLOBALS")) {
//            	for(int i = 0; i < root.getChildNodes().getLength(); i++) {
//            		Node n = root.getChildNodes().item(i); 		// should be "VARIABLE"
//            		if(n.getNodeName().equals("VARIABLE")) { 	// this should happen
//            			String dataValue = n.getTextContent();            				
//    					String name = n.getAttributes().getNamedItem("name").getNodeValue();
//    					String scope = n.getAttributes().getNamedItem("scope").getNodeValue();
//    					String type = n.getAttributes().getNamedItem("type").getNodeValue();
//    					VariableScope vscope; 
//    					VariableType vtype; 
//    					         					
//    					if(scope.equals("global"))
//    						vscope = VariableScope.GLOBAL;
//    					else
//    						continue; // must be global variable
//    					
//    					if(type.equals("number"))
//    						vtype = VariableType.NUMBER;
//    					else if(type.equals("boolean"))
//    						vtype = VariableType.BOOLEAN; 
//    					else // assume string
//    						vtype = VariableType.STRING;
//    					
//    					Variable v = new Variable(name, vtype, vscope, false);
//						
//						// This assumes that the variables have been compiled and are a part of the varList
//	        			int index = varList.indexOf(v);
//	        			long value = 0; 
//    					switch(v.getType()) {
//	        				case BOOLEAN :	        					
//	        					value = booleanToSlnum(Boolean.parseBoolean(dataValue));
//	        					break; 
//	        				case NUMBER :
//	        					value = doubleToSlnum(Double.parseDouble(dataValue));
//	        					break;
//	        				case STRING :	        					
//	        					value = addToHeap(dataValue);
//	        					break;
//	        			}    		
//    					globalHeap.put(index, value);
//            		}
//            	}
//            }
//        }
//        catch(Exception e) {
//        	e.printStackTrace(); 
//        }
//    }
//    
    
    //TODO cmcheng New Stuff for new functionality
//    public native void setUsingOldFormat(boolean boo);
    public void setUsingOldFormat(boolean b) {
    	// dummy
    }
//    public native void setupLineBuffer(FloatBuffer buf);
    
//    public void flushLines(int numLines) {
//    	//take everything out of line buffer and draw these lines
//    	//with the specified size and color
//    	
//    	for (int i = 0; i < numLines; i++) {
//    		float x1 = lineBuffer.get(i*6 + 0);
//    		float y1 = lineBuffer.get(i*6 + 1);
//    		float x2 = lineBuffer.get(i*6 + 2);
//    		float y2 = lineBuffer.get(i*6 + 3);
//    		float color = lineBuffer.get(i*6 + 4);
//    		float thickness = lineBuffer.get(i*6 + 5);
//    		
//    		x1 = x1 * pm.getCurrentTerrain().getAssociatedWidth() / pm.getCurrentTerrain().getWidth();
//        	y1 = y1 * pm.getCurrentTerrain().getAssociatedHeight() / pm.getCurrentTerrain().getHeight();
//        	x2 = x2 * pm.getCurrentTerrain().getAssociatedWidth() / pm.getCurrentTerrain().getWidth();
//        	y2 = y2 * pm.getCurrentTerrain().getAssociatedHeight() / pm.getCurrentTerrain().getHeight();
//        	
//        	//r is given in terms of patches, need to mult it by the patch size
//        	thickness = pm.getCurrentTerrain().getPatchSize() * thickness *
//        		pm.getCurrentTerrain().getAssociatedWidth() / pm.getCurrentTerrain().getWidth();
//    		
//    		Color c = Colors.slColorToColor(color);
//    		pm.getCurrentTerrain().drawThickLine((int)x1, (int)y1, (int)x2, (int)y2, 
//    				c, (int)thickness);
//    		
//    	}
//    	
//    }
//        
//    
//    /**
//     * Called from VM. Stamps a circle of color of size r in position x and y,
//     * where x and y are 0 to 101
//     * @param x X Coordinate, 0 is left most edge, 101 is right most edge
//     * @param y Y Coordinate, 0 is up most edge, 101 is down most edge
//     * @param r Radius, in terms of patch size (r = 1 means 1 patch size)
//     * @param color Color, in starlogo format.
//     */
//    public void stampCircle(float x, float y, float r, float color) {
//    	
//    	//X and Y passed in go from left to right, and up to down, and are 0 to 101
//    	//(from edge to edge, first box is 0 to 1, next is 1 to 2...
//    	x = x * pm.getCurrentTerrain().getAssociatedWidth() / 101.0f;
//    	y = y * pm.getCurrentTerrain().getAssociatedHeight() / 101.0f;
//    	
//    	//r is given in terms of patches, need to mult it by the patch size
//    	float pixelRadius = pm.getCurrentTerrain().getPatchSize() * r *
//    		pm.getCurrentTerrain().getAssociatedWidth() / 101.0f;
//    	
//    	//Converting the color
//    	Color c = Colors.slColorToColor(color);
//    	
//    	//long l = StarLogo.doubleToSlnum((double)color);
//    	//float[] colorVect =	Colors.colorarray[(int)(StarLogo.slnumToDouble(l)*32)].getRGBComponents(null);
//    	//Color c = new Color(colorVect[0], colorVect[1], colorVect[2]);
//    	
//    	pm.getCurrentTerrain().fillEllipse(
//    			Math.round(x - (pixelRadius/2.0f)), Math.round(y - (pixelRadius/2.0f)),
//    			Math.round(x + (pixelRadius/2.0f)), Math.round(y + (pixelRadius/2.0f)), 
//    			c);
//    	
//    }
//    
//    /**
//     * Called from C code. This is for the block stamp_patch
//     * @param x
//     * @param y
//     * @param color
//     */
//    public void stampPatch(float x, float y, float color) {
//    	
//    	int patchX = (int)x;
//    	int patchY = (int)y;
//    	
//    	Color c = Colors.slColorToColor(color);
//    	
//    	pm.getCurrentTerrain().paintPatch(patchX, patchY, c);
//    }
//    
//    
//    /**
//     * Called from Java code. (Not used currently) (Need to change VM)
//     * Take two patch coordinates and get combined color of patch and texture.
//     * 
//     * Returns slnum format
//     * 
//     * @param patchX
//     * @param patchY
//     */
//    public float getColorOfPosition(float patchX, float patchY) {
//    	//Given a position x,y of a patch, lookup what color this is on the
//    	//texture and/or patch and print it out
//    	
//    	float x = patchX * pm.getCurrentTerrain().getAssociatedWidth() / 101.0f;
//    	float y = patchY * pm.getCurrentTerrain().getAssociatedHeight() / 101.0f;
//    	
//    	Color texColor = pm.getCurrentTerrain().getTextureColor((int) x, (int) y);
//    	
//    	//get the patch color
//    	Color patchColor = pm.getCurrentTerrain().getColor((int) patchX, (int) patchY);
//    	
//    	//the actual color is these two colors anded together (min of each)
//    	Color totalColor = new Color(
//    			Math.min(texColor.getRed(), patchColor.getRed()),
//    			Math.min(texColor.getGreen(), patchColor.getGreen()),
//    			Math.min(texColor.getBlue(), patchColor.getBlue())
//    	);
//    	
//    	double returnvalue = Colors.mapColorToStarLogoColor(totalColor.getRed(), 
//    			totalColor.getGreen(), totalColor.getBlue());
//    	//System.out.println("Color");
//    	//System.out.println(totalColor);
//    	
//    	// djwendel - FIXME this is a hack to make up for that fact that
//    	// the current Colors.java implementation isn't symmetrical!
//    	// Stamping a color and then reading the patch color will give you
//    	// a different result (off by a fraction).  So this rounds back to whole #'s.
//    	return Math.round(returnvalue);
//    }
//    
    
//    
//    /**
//     * may not be necessary
//     * @param patchX
//     * @return
//     */
//    private float patchXToTexX(float patchX) {
//    	return patchX * pm.getCurrentTerrain().getAssociatedWidth() / 101.0f;
//    }
//    
//    /**
//     * may not be necessary
//     * @param patchY
//     * @return
//     */
//    private float patchYToTexY(float patchY) {
//    	return patchY * pm.getCurrentTerrain().getAssociatedHeight() / 101.0f;
//    }
//    
//    /**
//     * Checking if two floats are equal. (Approximately the same)
//     * @param x
//     * @param target
//     * @return
//     */
//    private boolean floatEquals(float x, float target) {
//    	return Math.abs(x - target) < 0.01;
//    }
//    
//    /**
//     * Untested
//     * 
//     * Map colors to starlogo color blocks, then check for fuzzy equals
//     */
//    private boolean fuzzyColorEquals(Color c, Color target) {
//    	double c_color = Colors.mapColorToStarLogoColor(c.getRed(), c.getGreen(), c.getBlue());
//    	double target_color = Colors.mapColorToStarLogoColor(target.getRed(), target.getGreen(), target.getBlue());
//    
//    	float cc = (float)c_color;
//    	float targetc = (float)target_color;
//    	
//    	return Math.abs(cc - targetc) < 0.5f;
//    	
//    }
//    
//    /**
//     * We check all pixels on the texture to see if a pixel of the specified color
//     * is a certain amount of distance in the direction of heading from the point
//     * patchX, patchY
//     * 
//     * Currently checks the color of texture only, fuzzy matched to the specified
//     * color from vm.
//     * 
//     * curently uses 4 helper methods, 
//     * floatequals
//     * patchytotexy
//     * patchxtotexx
//     * slcolortocolor
//     * @param patchX
//     * @param patchY
//     * @param heading
//     * @param distance
//     * @param color
//     * @return
//     */
//    public int checkColorInFront(float patchX, float patchY, 
//    		float heading, float distance, float color) {
//    	
//    	// convert patch distance to texel distance (djwendel)
//    	// FIXME - should use dynamic conversion, not a hard-coded 5! 
//    	// But TerrainData's texture resolution is hard-coded now too.
//    	distance = distance * 5;
//    	
//    	//For testing
//    	//Color pc = pm.getCurrentTerrain().getColor((int) patchX, (int) patchY);
//    	//double pcsl = Colors.mapColorToStarLogoColor(pc.getRed(), pc.getGreen(), pc.getBlue());	
//    	//Color xx = slColorToColor(color);
//    	//double xxsl = Colors.mapColorToStarLogoColor(xx.getRed(), xx.getGreen(), xx.getBlue());
//
//    	
//    	//Not for testing
//    	Color targetColor = Colors.slColorToColor(color);
//    	int startX = (int)patchXToTexX(patchX);
//    	int startY = (int)patchYToTexY(patchY);
//    	TerrainData td = pm.getCurrentTerrain();
//    	
//    	//For testing
//    	//System.out.println("Testing");
//    	//Color ccc = td.getTextureColor(startX, startY);
//    	//double sss = Colors.mapColorToStarLogoColor(ccc.getRed(), ccc.getGreen(), ccc.getBlue());
//    	//System.out.println("Transformed color: " + sss);
//    	//System.out.println("Patch color: " + pcsl);
//    	
//    	
//    	//If we're not even on the texture, return false;
//    	if (!td.xInsideTexture(startX) || !td.yInsideTexture(startY)) {
//			return 0;
//		}
//
//    	//Special Cases: Heading is horizontal or vertical
//    	if (floatEquals(heading,0) || floatEquals(heading,360)) {
//    		//we're looking directly up, keep decrementing y until distance
//    		//or off map
//    		int stopY = startY - (int)distance;
//    		for (int y = startY; y >= stopY; y--) {
//    			if (!td.yInsideTexture(y)) {
//        			return 0;
//        		}
//        		//check the color of patch - true ==> return true
//        		if (fuzzyColorEquals(td.getTextureColor(startX, y), targetColor)) {
//        			return 1;
//        		}
//        		
//        		//for testing only
//        		//td.fillRectangle(startX, y, startX + 1, y + 1, Color.WHITE);
//
//    		}
//    		return 0;
//    	}
//    	if (floatEquals(heading,90)) {
//    		//we're looking directly right, keep incrementing x until distance
//    		//or off map
//    		int stopX = startX + (int)distance;
//    		for (int x = startX; x <= stopX; x++) {
//    			if (!td.xInsideTexture(x)) {
//        			return 0;
//        		}
//        		//check the color of patch - true ==> return true
//        		if (fuzzyColorEquals(td.getTextureColor(x, startY), targetColor)) {
//        			return 1;
//        		}
//    		}
//    		return 0;
//    	}
//    	if (floatEquals(heading,180)) {
//    		//we're looking directly down, keep incrementing y until distance
//    		//or off map
//    		int stopY = startY + (int)distance;
//    		for (int y = startY; y <= stopY; y++) {
//    			if (!td.yInsideTexture(y)) {
//        			return 0;
//        		}
//        		//check the color of patch - true ==> return true
//        		if (fuzzyColorEquals(td.getTextureColor(startX, y), targetColor)) {
//        			return 1;
//        		}
//    		}
//    		return 0;
//    	}
//    	if (floatEquals(heading,270)) {
//    		//we're looking directly left, keep decrementing x until distance
//    		//or off map
//    		int stopX = startX - (int)distance;
//    		for (int x = startX; x >= stopX; x--) {
//    			if (!td.xInsideTexture(x)) {
//        			return 0;
//        		}
//        		//check the color of patch - true ==> return true
//        		if (fuzzyColorEquals(td.getTextureColor(x, startY), targetColor)) {
//        			return 1;
//        		}
//    		}
//    		return 0;
//    	}
//
//    	//All other Cases: Heading is slanted
//    	//Strategy: Use a ray, defining positive t in direction of heading
//    	//At any given point, check the t of the next X (right or left depending on heading)
//    	//and the next Y (up or down depending on heading) and find out which is smaller
//    	//This gives us the next pixel to check. And repeat this process
//    	
//    	//Ray r: x = startX + t*(1 or -1 depending on heading)
//    	//		 y = startY + t*(slope or -slope depending on heading)
//    	double slope = 0;
//    	int currentX = startX; //the next x boundary we are checking
//    	int currentY = startY; //the next y boundary we are checking
//
//    	//Depending on heading, the next X will be +1 if heading right, or -1 if left
//    	//next Y will be -1 if heading up or +1 if heading down
//    	//0 faces upwards, continue clockwise to 360, and can't be anything else
//    	int changeX = 0;
//    	int changeY = 0;
//    	if (heading > 0 && heading < 90) {
//    		//up right
//    		changeX = 1;
//    		changeY = -1;
//    	}
//    	else if (heading > 90 && heading < 180) {
//    		//down right
//    		changeX = 1;
//    		changeY = 1;
//    	}
//    	else if (heading > 180 && heading < 270) {
//    		//down left
//    		changeX = -1;
//    		changeY = 1;
//    	}
//    	else {
//    		//up left
//    		changeX = -1;
//    		changeY = -1;
//    	}
//    	
//    	//We need to negate the slope when heading left since
//    	//we want positive parameter t when moving in direction of heading
//    	if (heading > 90 && heading < 180) {
//    		//pos x and pos y --> map to 0 to 90
//    		slope = Math.tan(Math.toRadians(heading - 90));
//    	}
//    	else if (heading > 0 && heading < 90) {
//    		//0 to 90 map to 270 to 360
//    		slope = Math.tan(Math.toRadians(heading + 270));
//    	}
//    	else if (heading > 180 && heading < 270) {
//    		slope = -1*Math.tan(Math.toRadians(heading - 90));
//    	}
//    	else {
//    		slope = -1*Math.tan(Math.toRadians(heading - 90));
//    	}
//    	
//
//
//    	while (true) {
//    		//if x or y is outside board ==> return false
//    		if (!td.xInsideTexture(currentX) || !td.yInsideTexture(currentY)) {
//    			return 0;
//    		}
//
//    		//check the color of patch - true ==> return true
//    		if (fuzzyColorEquals(td.getTextureColor(currentX, currentY), targetColor)) {
//    			return 1;
//    		}
//    		
//    		//for testing only
//    		//td.fillRectangle(currentX, currentY, currentX + 1, currentY + 1, Color.WHITE);
//
//    		//check t of next x or next y
//    		//newx = oldx + (1 or -1)t if we're looking right or left
//    		//t = newx - oldx/1 or -1
//    		//
//    		//newy = oldy + slope*t (note that we incorporate negative into the slope)
//    		//t = newy - oldy/slope
//    		double tx = ((currentX + changeX) - startX)/changeX;
//    		double ty = ((currentY + changeY) - startY)/slope;
//    		double nextT = 0;
//
//    		//increment x if tx is lower, increment y if ty is lower
//    		//but if t's are close enough together, increment x and y
//    		if (Math.abs(ty - tx) < 1e-5) {
//    			currentX += changeX;
//    			currentY += changeY;
//    			nextT = tx;
//    		}
//    		else if (tx < ty) {
//    			currentX += changeX;
//    			nextT = tx;
//    		}
//    		else {
//    			currentY += changeY;
//    			nextT = ty;
//    		}
//
//    		//if t outside distance ==> return false
//    		if (nextT * Math.sqrt(1 + slope*slope) > distance) {
//    			return 0;
//    		}
//
//    	}
//    }
    
    
}
